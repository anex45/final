[
  {
    "question": "What is the difference between a list and a tuple in Python?",
    "correct_answer": "Lists are mutable, meaning they can be modified after creation, while tuples are immutable. Lists use square brackets [] and tuples use parentheses (). Lists generally consume more memory than tuples and are slower for iteration.",
    "detailed_feedback": "Your answer correctly identifies the key difference between lists and tuples - mutability. Lists can be modified after creation while tuples cannot. You've also mentioned the syntax differences (square brackets vs parentheses) and performance characteristics. To enhance your answer, you could also mention that tuples can be used as dictionary keys due to their immutability, while lists cannot. Additionally, you might explain that tuples are often used for heterogeneous data while lists are typically used for homogeneous data collections."
  },
  {
    "question": "Explain how Python handles memory management.",
    "correct_answer": "Python uses automatic memory management with a private heap to store objects and data structures. It has a built-in garbage collector that reclaims memory from objects that are no longer referenced. Python uses reference counting as its primary memory management technique, along with cycle-detecting garbage collection to handle circular references.",
    "detailed_feedback": "Your response demonstrates a strong understanding of Python's memory management. You've correctly explained that Python uses automatic memory management with reference counting and garbage collection. Your mention of the private heap and handling of circular references shows depth of knowledge. To make your answer even more comprehensive, you could discuss how the memory manager allocates/deallocates memory blocks and how Python's memory pooling works for small objects to improve efficiency."
  },
  {
    "question": "What are Python decorators and how do they work?",
    "correct_answer": "Python decorators are functions that modify the functionality of other functions. They use the @decorator syntax and allow for metaprogramming. Decorators wrap a function, modifying its behavior without permanently modifying the function itself. They are called before the function they decorate is called.",
    "detailed_feedback": "Your explanation of decorators covers the essential concept that they modify the functionality of other functions. You've correctly mentioned the @decorator syntax and that they wrap functions. To improve your answer, you could provide a simple example showing a decorator definition and application. Also, explaining that decorators are higher-order functions that take a function as an argument and return a function would demonstrate deeper understanding of the concept."
  },
  {
    "question": "What is the difference between multiprocessing and multithreading in Python?",
    "correct_answer": "Multiprocessing uses separate processes with their own memory space, allowing true parallel execution and bypassing the GIL, but with higher overhead for inter-process communication. Multithreading uses threads within a single process sharing memory space, which is more efficient for I/O-bound tasks but limited by the GIL for CPU-bound tasks.",
    "detailed_feedback": "Your answer effectively distinguishes between multiprocessing and multithreading in Python. You've correctly identified that multiprocessing uses separate processes with their own memory space while multithreading uses threads within a single process. Your mention of the Global Interpreter Lock (GIL) and its impact on both approaches shows good understanding. To enhance your answer, you could discuss specific use cases where each approach is preferable and mention the multiprocessing and threading modules in Python's standard library."
  },
  {
    "question": "Explain the asyncio module in Python and how it works.",
    "correct_answer": "The asyncio module provides infrastructure for writing single-threaded concurrent code using coroutines, multiplexing I/O access over sockets and other resources. It's a form of cooperative multitasking where tasks voluntarily yield control when they are waiting for I/O, allowing other tasks to run. It uses an event loop to manage and distribute the execution of different tasks.",
    "detailed_feedback": "Your explanation of asyncio covers the key concepts of single-threaded concurrency and coroutines. You've correctly described the event loop model and how tasks yield control during I/O operations. To make your answer more comprehensive, you could explain the difference between asyncio and traditional threading/multiprocessing, discuss async/await syntax introduced in Python 3.5+, and provide a simple example showing how to define and run coroutines with asyncio."
  },
  {
    "question": "What are Python generators and how do they differ from regular functions?",
    "correct_answer": "Generators are functions that return an iterator that yields items one at a time, suspending execution between yields. They use the 'yield' keyword instead of 'return'. Unlike regular functions that compute and return a value all at once, generators produce values lazily and only when needed, which makes them memory-efficient for large datasets.",
    "detailed_feedback": "Your answer correctly explains that generators are functions that yield items one at a time and suspend execution between yields. You've identified the key 'yield' keyword that distinguishes generators from regular functions. Your explanation of lazy evaluation and memory efficiency is excellent. To enhance your answer, you could provide a simple example contrasting a generator with a regular function, and mention generator expressions as a concise way to create generators similar to list comprehensions."
  },
  {
    "question": "Explain the concept of list comprehensions in Python.",
    "correct_answer": "List comprehensions are a concise way to create lists in Python. They consist of brackets containing an expression followed by a for clause, then zero or more for or if clauses. The expressions can be anything, meaning you can put in all kinds of objects in lists. They are more compact and often faster than traditional for loops for creating lists.",
    "detailed_feedback": "Your explanation of list comprehensions covers the basic concept well - they are a concise way to create lists. You've correctly described their syntax with an expression followed by for and if clauses. To improve your answer, you could provide a simple example comparing a traditional for loop with a list comprehension. Also, mentioning that list comprehensions have better performance for many operations and discussing related concepts like generator expressions and dictionary/set comprehensions would demonstrate deeper knowledge."
  },
  {
    "question": "What is the Global Interpreter Lock (GIL) in Python?",
    "correct_answer": "The Global Interpreter Lock (GIL) is a mutex that protects access to Python objects, preventing multiple threads from executing Python bytecode at once. This means that even in multi-threaded applications, only one thread can execute Python code at any given time. The GIL simplifies memory management but limits CPU-bound concurrency in multi-threaded Python programs.",
    "detailed_feedback": "Your answer provides a clear explanation of the Global Interpreter Lock (GIL) as a mutex that prevents multiple threads from executing Python bytecode simultaneously. You've correctly identified its impact on concurrency and that it simplifies memory management. To enhance your answer, you could explain why the GIL exists (to protect Python's memory management which isn't thread-safe), mention that it primarily affects CPU-bound rather than I/O-bound tasks, and discuss workarounds like multiprocessing or using alternative Python implementations such as Jython or IronPython that don't have a GIL."
  },
  {
    "question": "How does exception handling work in Python?",
    "correct_answer": "Python uses try, except, else, and finally blocks for exception handling. Code that might raise an exception is placed in the try block. The except block catches and handles specific exceptions. The optional else block executes if no exceptions occur, and the finally block always executes regardless of whether an exception occurred. Python uses a hierarchical exception class structure, allowing for catching specific or general exception types.",
    "detailed_feedback": "Your answer provides a comprehensive overview of Python's exception handling mechanism with try, except, else, and finally blocks. You've correctly explained the purpose of each block and mentioned Python's hierarchical exception structure. To make your answer even better, you could provide a simple example demonstrating these blocks in action. Additionally, mentioning the ability to create custom exception classes by inheriting from Exception and discussing best practices like catching specific exceptions rather than using bare except clauses would show deeper understanding."
  },
  {
    "question": "Explain the difference between '==' and 'is' operators in Python.",
    "correct_answer": "The '==' operator compares the values of objects (equality), while the 'is' operator checks if two variables reference the same object in memory (identity). For example, two different lists with the same elements will return True with ==, but False with is. However, for immutable objects like small integers or strings, Python may reuse objects, so 'is' might return True when comparing identical values due to interning.",
    "detailed_feedback": "Your answer clearly distinguishes between the '==' operator for value equality and the 'is' operator for identity comparison. Your example with lists effectively illustrates this difference. You've also correctly mentioned Python's object interning for small immutable objects, which is an advanced concept. To enhance your answer further, you could provide a specific code example demonstrating both operators with different types of objects, and explain when to use each operator appropriately (e.g., 'is' is commonly used for comparing with None, while '==' is used for value comparisons)."
  },
  {
    "question": "What are Python context managers and how do they work?",
    "correct_answer": "Context managers in Python are objects that define the methods __enter__() and __exit__() to establish and exit a runtime context. They're typically used with the 'with' statement to ensure resources are properly managed, like automatically closing files or releasing locks, even if exceptions occur. The __enter__ method sets up the context and returns a value, while __exit__ handles cleanup when the block completes or an exception is raised.",
    "detailed_feedback": "Your explanation of context managers covers their essential purpose - managing resources and ensuring proper cleanup. You've correctly identified the __enter__ and __exit__ methods and their connection to the 'with' statement. To improve your answer, you could provide a simple example of using a context manager with a file operation, and mention the contextlib module which provides utilities for creating context managers, particularly the @contextmanager decorator that allows creating context managers using generators instead of defining a class with __enter__ and __exit__ methods."
  },
  {
    "question": "Explain the concept of duck typing in Python.",
    "correct_answer": "Duck typing is a programming concept in Python where the type or class of an object is less important than the methods it defines or the operations it supports. The name comes from the saying, 'If it walks like a duck and quacks like a duck, then it probably is a duck.' In Python, instead of checking an object's type, you simply try to use it as expected, and if it has the necessary attributes and methods, it works regardless of its actual type.",
    "detailed_feedback": "Your answer provides a clear explanation of duck typing in Python, capturing its essence that behavior is more important than type. The duck analogy is well explained. You've correctly emphasized that Python focuses on what an object can do rather than what it is. To enhance your answer, you could provide a concrete example showing how different classes that implement the same method can be used interchangeably. Also, contrasting duck typing with static typing and discussing how it relates to Python's polymorphism would demonstrate deeper understanding of the concept."
  },
  {
    "question": "What are metaclasses in Python and how would you use them?",
    "correct_answer": "Metaclasses are classes that create other classes. In Python, classes are themselves objects, and metaclasses are the classes of these objects. The built-in type is the default metaclass. You can define custom metaclasses by inheriting from type and overriding methods like __new__ or __init__ to customize class creation. Metaclasses are used for framework development, enforcing coding standards, registering classes, or adding methods/attributes to classes automatically.",
    "detailed_feedback": "Your answer demonstrates a strong understanding of metaclasses as 'classes that create classes.' You've correctly identified type as the default metaclass and explained how to create custom metaclasses. Your examples of use cases are spot on. To make your answer even more comprehensive, you could provide a simple code example showing a metaclass implementation, explain the class creation process in Python (__new__ vs __init__ in metaclasses), and mention the __prepare__ method introduced in Python 3 for controlling the namespace creation. Also, discussing the metaclass parameter in class definitions would round out your explanation."
  },
  {
    "question": "Explain the concept of closures in Python with an example.",
    "correct_answer": "A closure in Python is a function object that remembers values in enclosing scopes even if they are not present in memory. It occurs when a nested function references a value from its enclosing function. For example, def outer(x): def inner(): return x+1; return inner creates a closure where inner 'remembers' the value of x from outer's scope even after outer has finished execution.",
    "detailed_feedback": "Your explanation of closures correctly identifies them as functions that remember values from enclosing scopes. Your example effectively demonstrates how a nested function can access and remember variables from its parent function's scope. To enhance your answer, you could explain the practical applications of closures, such as in function factories, maintaining state without using class instances, or implementing decorators. Also, mentioning the nonlocal keyword introduced in Python 3 for modifying enclosed scope variables would show deeper understanding of how closures work in Python."
  },
  {
    "question": "What are Python's magic methods and how would you use them?",
    "correct_answer": "Magic methods (or dunder methods) in Python are special methods surrounded by double underscores, like __init__ or __str__. They allow classes to emulate built-in types or implement operator overloading. For example, __add__ implements the + operator, __len__ allows an object to work with len(), and __str__ controls string representation. They're called automatically by Python when the corresponding operation is performed on the object.",
    "detailed_feedback": "Your answer provides a good overview of magic methods in Python, correctly identifying them as special methods with double underscores that enable operator overloading and built-in type emulation. Your examples of __add__, __len__, and __str__ are appropriate. To make your answer more comprehensive, you could categorize magic methods by their purposes (initialization, representation, comparison, numeric operations, container behavior, etc.) and provide a simple class example implementing several magic methods to demonstrate how they work together to create a well-behaved Python object. Also, mentioning that these methods are part of Python's data model would show deeper understanding."
  }
]